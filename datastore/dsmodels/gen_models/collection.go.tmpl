// {{.GoName}} has all fields from {{.ModelsName}}.
type {{.GoName}} struct{
    {{- range .Fields}}
    {{.Name}} {{.Type}}
    {{- end}}
    {{- range .Relations}}
    {{.StructFieldName}} {{.ResultType}}
    {{- end}}
    fetch *Fetch
}

func (c *{{.GoName}})lazy(ds *Fetch, id int) {
    c.fetch = ds
    {{- range .Fields}}
    ds.{{.FetchName}}(id).Lazy(&c.{{.Name}})
    {{- end}}
}

{{ range .Relations}}
func (c *{{$.GoName}}) {{.MethodName}}() {{.ResultType}}{
    if c.{{.StructFieldName}} == nil {
        {{- if .IsList}}
        refs := make([]*ValueCollection[{{.Type}}, *{{.Type}}], len(c.{{.FieldName}}))
        for i, id := range c.{{.FieldName}}{
            refs[i] = &ValueCollection[{{.Type}}, *{{.Type}}]{
                id: id,
                fetch: c.fetch,
            }
        }
        c.{{.StructFieldName}} = &RelationList[{{.Type}}, *{{.Type}}]{refs}
        {{- else if .Required}}
        c.{{.StructFieldName}} = &ValueCollection[{{.Type}}, *{{.Type}}]{
		    id: c.{{.FieldName}},
		    fetch: c.fetch,
	    }
	    {{- else}}
        var ref dsfetch.Maybe[*ValueCollection[{{.Type}}, *{{.Type}}]]
	    id, hasValue := c.{{.FieldName}}.Value()
	    if hasValue {
	        value := &ValueCollection[{{.Type}}, *{{.Type}}]{
		        id:    id,
		        fetch: c.fetch,
	        }
	        ref.Set(value)
	    }
        c.{{.StructFieldName}} = &MaybeRelation[{{.Type}}, *{{.Type}}]{ref}
	    {{- end}}
	}
    return c.{{.StructFieldName}} 
}
{{end}}

func (r *Fetch){{.GoName}}(id int) *ValueCollection[{{.GoName}}, *{{.GoName}}]{
	return &ValueCollection[{{.GoName}}, *{{.GoName}}]{
		id: id,
		fetch: r,
	}
}
